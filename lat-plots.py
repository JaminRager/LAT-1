#!/usr/bin/env python3
"""
===================== lat-plots.py ======================
A semi-official place to put plots of interest, primarily
using the "final" LAT cut files generated by lat-expo.py
=================== C. Wiseman (USC) ===================
"""
import numpy as np
import matplotlib.pyplot as plt
plt.style.use('./pltReports.mplstyle')
from matplotlib.colors import LogNorm

import dsi
bkg = dsi.BkgInfo()
det = dsi.DetInfo()
cal = dsi.CalInfo()
import waveLibs as wl

def main():

    # spec()
    # spec_vs_cpd()
    # thresh_cut_cal()
    # ds3_trig_eff()
    # hi_mult_cal_spec()
    # m2s238_sum_peak()
    # m2s238_hit_spec()
    slowness_vs_energy()


def spec():
    from ROOT import TFile, TChain, TTree

    dsList = [0,1,2,3,4,"5A","5B","5C"]

    tt = TChain("skimTree")
    enrExp, natExp = 0, 0
    for ds in dsList:
        inFile = "%s/bkg/cut/final/final_DS%s.root" % (dsi.dataDir, ds)
        tf = TFile(inFile)
        enrExp += float(tf.Get("enrExp (kg-d)").GetTitle())
        natExp += float(tf.Get("natExp (kg-d)").GetTitle())
        tf.Close()
        tt.Add(inFile)

    print("enrExp %.2f  natExp %.2f, ds" % (enrExp/365.25, natExp/365.25),dsList)

    fig = plt.figure(figsize=(8,7))
    p0 = plt.subplot(211)
    p1 = plt.subplot(212)
    xLo, xHi, xpb = 0, 20, 0.1

    # natural
    tCut = "!isEnr"
    n = tt.Draw("trapENFCal",tCut,"goff")
    hitE = tt.GetV1()
    hitE = [hitE[i] for i in range(n)]
    x, h1 = wl.GetHisto(hitE, xLo, xHi, xpb, shift=False)
    h1 = np.divide(h1, natExp*xpb) # scale by exposure and binning
    p0.plot(x, h1, 'b', ls='steps', lw=2, label="Natural")
    # p0.set_xlabel("Energy (keV)", ha='right', x=1)
    p0.set_ylabel("Counts/keV-kg-d", ha='right', y=1)
    p0.legend(loc=1)

    # enriched
    tCut = "isEnr"
    n = tt.Draw("trapENFCal",tCut,"goff")
    hitE = tt.GetV1()
    hitE = [hitE[i] for i in range(n)]
    x, h1 = wl.GetHisto(hitE, xLo, xHi, xpb, shift=False)
    h1 = np.divide(h1, enrExp*xpb) # scale by exposure and binning
    p1.plot(x, h1, 'b', ls='steps', lw=2, label="Enriched")
    p1.set_xlabel("Energy (keV)", ha='right', x=1)
    # p1.set_ylabel("Counts/keV-kg-d", ha='right', y=1)
    p1.legend(loc=1)

    plt.tight_layout()
    plt.show()


def spec_vs_cpd():
    from ROOT import TFile, TChain, TTree

    dsList = [0,1,2,3,4,"5A","5B","5C"]

    tt = TChain("skimTree")
    enrExp, natExp = 0, 0
    for ds in dsList:
        inFile = "%s/bkg/cut/final/final_DS%s.root" % (dsi.dataDir, ds)
        tf = TFile(inFile)
        enrExp += float(tf.Get("enrExp (kg-d)").GetTitle())
        natExp += float(tf.Get("natExp (kg-d)").GetTitle())
        tf.Close()
        tt.Add(inFile)
    print("enrExp %.2f  natExp %.2f, ds" % (enrExp/365.25, natExp/365.25),dsList)

    # the channel map changes across datasets, so we have to plot by CPD

    cpdList = []
    for ds in dsList:
        dsTmp = int(ds[0]) if isinstance(ds,str) else ds
        chTmp = det.getGoodChanList(dsTmp)
        for ch in chTmp:
            cpdList.append(int(det.getChanCPD(dsTmp,ch)))
    cpdList = sorted(list(set(cpdList)))

    enrList = [cpd for cpd in cpdList if det.allDetIDs[str(cpd)] > 100000]
    cpdEnrMap = {enrList[i]:i for i in range(len(enrList))}
    # enrLabels = enrList

    natList = [cpd for cpd in cpdList if det.allDetIDs[str(cpd)] < 100000]
    cpdNatMap = {natList[i]:i for i in range(len(natList))}
    # natLabels =


    fig = plt.figure(figsize=(8,7))
    p0 = plt.subplot(211)
    p1 = plt.subplot(212)
    xLo, xHi, xpb = 0, 20, 0.2

    # natural
    tCut = "!isEnr"
    yLo, yHi = 0, len(natList)
    nbx, nby = int((xHi-xLo)/xpb), len(natList)

    n = tt.Draw("trapENFCal:C:P:D",tCut,"goff")
    hitE, hitC, hitP, hitD = tt.GetV1(), tt.GetV2(), tt.GetV3(), tt.GetV4()
    hitE = [hitE[i] for i in range(n)]
    hitCPD = [cpdNatMap[ int("%d%d%d" % (hitC[i],hitP[i],hitD[i])) ] for i in range(n)]

    hNat,_,_,im0 = p0.hist2d(hitE, hitCPD, bins=[nbx, nby], range=[[xLo,xHi],[yLo,yHi]], cmap='jet')
    # p0.set_xlabel("Energy (keV)", ha='right', x=1.)
    p0.set_xticks(np.arange(xLo, xHi+1, 1.0))
    p0.set_ylabel("CPD, Natural", ha='right', y=1.)
    p0.set_yticks(np.arange(0, len(natList))+0.5)
    p0.set_yticklabels(natList, fontsize=8)

    # enriched
    tCut = "isEnr"
    yLo, yHi = 0, len(enrList)
    nbx, nby = int((xHi-xLo)/xpb), len(enrList)

    n = tt.Draw("trapENFCal:C:P:D",tCut,"goff")
    hitE, hitC, hitP, hitD = tt.GetV1(), tt.GetV2(), tt.GetV3(), tt.GetV4()
    hitE = [hitE[i] for i in range(n)]
    hitCPD = [ cpdEnrMap[int("%d%d%d" % (hitC[i],hitP[i],hitD[i])) ] for i in range(n)]

    hEnr,_,_,im1 = p1.hist2d(hitE, hitCPD, bins=[nbx, nby], range=[[xLo,xHi],[yLo,yHi]], cmap='jet')
    p1.set_xlabel("Energy (keV)", ha='right', x=1.)
    p1.set_xticks(np.arange(xLo, xHi+1, 1.0))
    p1.set_ylabel("CPD, Enriched", ha='right', y=1.)
    p1.set_yticks(np.arange(0, len(enrList))+0.5)
    p1.set_yticklabels(enrList, fontsize=8)

    cb0 = fig.colorbar(im0, ax=p0)
    cb1 = fig.colorbar(im1, ax=p1)
    # cb0.set_label('cts', ha='right', rotation=270, labelpad=20)


    plt.tight_layout()
    # plt.show()
    plt.savefig("./plots/lat-spec-vs-cpd.pdf")

    # ========= get detector counts =========

    eLo, eHi = 10, 11
    bLo, bHi = int(eLo/xpb), int(eHi/xpb)

    print("Natural Counts, %d-%d keV" % (eLo, eHi))
    for cpd in natList:
        col = cpdNatMap[cpd]
        print(cpd, int(np.sum(hNat[bLo:bHi,col])))

    print("Enriched Counts, %d-%d keV" % (eLo, eHi))
    for cpd in enrList:
        col = cpdEnrMap[cpd]
        print(cpd, int(np.sum(hEnr[bLo:bHi,col])))


def thresh_cut_cal():
    """ Adapted from LAT/sandbox/mult2.py, and dependent on input:
    "./data/mult2-dtVals-ene.npz"
    """
    import tinydb as db
    dsNum, bkgIdx = 5, 83
    calDB = db.TinyDB('./calDB.json')
    pars = db.Query()
    thD = dsi.getDBRecord("thresh_ds%d_bkgidx%d" % (dsNum, bkgIdx), False, calDB, pars)
    det = dsi.DetInfo()

    f = np.load("./data/mult2-dtVals-ene.npz")
    dtVals = f['arr_0'].item()
    mH = 1
    n = len(dtVals[mH])

    # plot 1: all hits under 10 keV
    # chan = [dtVals[mH][i][1][0] for i in range(n) if dtVals[mH][i][2][0]<10]
    # hitE = [dtVals[mH][i][2][0] for i in range(n) if dtVals[mH][i][2][0]<10]
    chan = [dtVals[mH][i][1][0] for i in range(n) if dtVals[mH][i][1][0] not in [598,1172] and dtVals[mH][i][2][0]<10]
    hitE = [dtVals[mH][i][2][0] for i in range(n) if dtVals[mH][i][1][0] not in [598,1172] and dtVals[mH][i][2][0]<10]

    # plot 2: only take hits above the detector threshold.
    n = len(hitE)
    chanTh, hitETh = [], []
    for i in range(n):
        if chan[i] in thD.keys() and hitE[i] > thD[chan[i]][0] + 3*thD[chan[i]][1]:
            chanTh.append(chan[i])
            hitETh.append(hitE[i])

    # make the figure

    f = plt.figure(figsize=(10,6))
    p1 = plt.subplot(121)
    p2 = plt.subplot(122)

    chList = list(sorted(set(chan)))

    cpd = {ch : int(det.getChanCPD(dsNum, ch)) for ch in chList}
    cpdList = sorted([int(det.getChanCPD(dsNum, ch)) for ch in chList])
    cpdIdx = {cpdList[i]:i for i in range(len(cpdList))}

    cpdData = [cpdIdx[cpd[ch]] for ch in chan]
    cpdDataTh = [cpdIdx[cpd[ch]] for ch in chanTh]

    xLo, xHi, xpb = 0.5, 5., 0.1
    yLo, yHi = 0, len(chList)
    nbx, nby = int((xHi-xLo)/xpb), len(chList)



    h1,xedg1,yedg1 = np.histogram2d(hitE, cpdData, bins=[nbx,nby], range=[[xLo,xHi],[yLo,yHi]])
    h2,xedg2,yedg2 = np.histogram2d(hitETh, cpdDataTh, bins=[nbx,nby], range=[[xLo,xHi],[yLo,yHi]])
    h1, h2 = h1.T, h2.T

    hMin, hMax = np.amin(h1), np.amax(h2)
    hMin, hMax = 2, hMax*1.3
    h1[h1 < 0.1] = -1
    h2[h2 < 0.1] = -1

    im1 = p1.imshow(h1,cmap='jet',vmin=hMin,vmax=hMax, aspect='auto')#,norm=LogNorm())

    xticklabels = ["%.1f" % x for x in np.arange(-0.5, 5.5, 1.)]

    yticks = np.arange(0, len(cpdList))

    p1.set_xlabel("Energy (keV)", ha='right', x=1.)
    # p1.set_xticks(xticks)
    p1.set_xticklabels(xticklabels)
    p1.set_ylabel("CPD", ha='right', y=1.)
    p1.set_yticks(yticks)
    p1.set_yticklabels(cpdList, fontsize=12)
    cb1 = f.colorbar(im1, ax=p1)#, fraction=0.037, pad=0.04)
    # cb1.set_label('Counts', ha='right', rotation=270, labelpad=20)

    im2 = p2.imshow(h2,cmap='jet',vmin=hMin,vmax=hMax, aspect='auto')#,norm=LogNorm())
    p2.set_xlabel("Energy (keV)", ha='right', x=1.)
    # p2.set_xticks(xticks)
    p2.set_xticklabels(xticklabels)
    p2.set_ylabel("CPD", ha='right', y=1.)
    p2.set_yticks(yticks)
    p2.set_yticklabels(cpdList, fontsize=12)
    cb2 = f.colorbar(im2, ax=p2)#, fraction=0.037, pad=0.04)
    # cb2.set_label('Counts', ha='right', rotation=270, labelpad=20)

    plt.tight_layout()

    # plt.show()
    plt.savefig("./plots/lat-dtm1-thresh.pdf")


def ds3_trig_eff():
    """ Adapted from lat-expo.py::getEfficiency.
    Plots the combined trigger efficiency from each detector in DS3 separately.
    """
    import tinydb as db
    import lat3
    from ROOT import TFile, TTree
    import matplotlib.pyplot as plt
    plt.style.use('./pltReports.mplstyle')

    calDB = db.TinyDB('%s/calDB-v2.json' % (dsi.latSWDir))
    pars = db.Query()
    enrExc, natExc, _, _ = lat3.getOutliers(verbose=False, usePass2=False)

    mode = "trig"  # trigger efficiency only
    # mode = "all"   # does all PS

    # dsList = [0,1,2,3,4,"5A","5B","5C"]
    dsList = [3]

    # efficiency output
    xLo, xHi = 0, 20
    xEff = np.arange(xLo, xHi, 0.01)
    totEnrEff = {ds:np.zeros(len(xEff)) for ds in dsList}
    totNatEff = {ds:np.zeros(len(xEff)) for ds in dsList}
    detEff = {ds:{} for ds in dsList}
    for ds in dsList:
        detEff[ds] = {cpd:np.zeros(len(xEff)) for cpd in det.allDets}

    # recalculate these, make sure they match getExposure
    enrExp = {ds:0 for ds in dsList}
    natExp = {ds:0 for ds in dsList}

    # 1. loop over datasets
    for ds in dsList:

        # set DS stuff
        dsNum = int(ds[0]) if isinstance(ds,str) else ds
        nBkg = bkg.dsMap()[dsNum]
        bLo, bHi = 0, nBkg
        if ds=="5A": bLo, bHi = 0, 79
        if ds=="5B": bLo, bHi = 80, 112
        if ds=="5C": bLo, bHi = 113, 121
        bkgRanges = bkg.getRanges(ds)

        # get psa cut runs and detector fitSlo efficiencies
        f = np.load('./data/lat-psaRunCut-ds%s.npz' % ds)
        psaRuns = f['arr_0'].item() # {ch: [runLo1, runHi1, runLo2, runHi2, ...]}
        fsD = dsi.getDBRecord("fitSlo_cpd_eff", False, calDB, pars)

        # get burst cut
        dsTmp = ds
        if ds=="5A": dsTmp=50
        if ds=="5B": dsTmp=51
        if ds=="5C": dsTmp=52
        iE = np.where(enrExc[:,0]==dsTmp)
        iN = np.where(natExc[:,0]==dsTmp)
        skipList = np.vstack((enrExc[iE], natExc[iN]))
        # print(skipList)

        # load ds_livetime output
        tl = TFile("./data/ds_%s_livetime.root" % str(ds))
        lt = tl.Get("dsTree")

        # 2. loop over modules
        mods = [1]
        if dsNum == 4: mods = [2]
        if dsNum == 5: mods = [1,2]
        for mod in mods:

            calKey = "ds%d_m%d" % (dsNum, mod)
            if ds == "5C": calKey = "ds5c"
            if calKey not in cal.GetKeys(dsNum):
                print("Error: Unknown cal key:",calKey)
                return

            print("Scanning DS-%s, m%d ..." % (ds, mod))

            chList = det.getGoodChanList(dsNum, mod)

            # save total efficiency for each channel in this DS
            totEff = {ch:np.zeros(len(xEff)) for ch in chList}
            trigEff = {ch:np.zeros(len(xEff)) for ch in chList}
            fSloEff = {ch:np.zeros(len(xEff)) for ch in chList}

            # 3. loop over bkgIdx
            for i, bIdx in enumerate(bkgRanges):


                # load bkg (trigger) and cal (PSA) cut coverage
                _,_, bkgCov, calCov = dsi.GetDBCuts(ds,bIdx,mod,"fr",calDB,pars,False)

                rLo, rHi = bkgRanges[bIdx][0], bkgRanges[bIdx][-1]

                # get psa cut runs
                psaCutRuns = {ch:[] for ch in chList}
                for ch in chList:
                    if len(psaRuns[ch]) > 0:
                        for i in range(0,len(psaRuns[ch]),2):
                            psaCutRuns[ch].extend([r for r in range(psaRuns[ch][i],psaRuns[ch][i+1]+1) if rLo <= r <= rHi])

                # get burst cut runs
                burstCutRuns = {ch:False for ch in chList}
                for ch in chList:
                    cpd = det.getChanCPD(dsNum,ch)
                    iSkip = np.where((skipList == (dsTmp, int(cpd), bIdx)).all(axis=1))
                    if len(iSkip[0]) > 0:
                        burstCutRuns[ch] = True

                # 4. loop over sub-bIdx
                subRanges = bkg.GetSubRanges(ds, bIdx)
                if len(subRanges) == 0: subRanges.append((rLo, rHi))
                for sbIdx, (subLo, subHi) in enumerate(subRanges):

                    # load trigger efficiencies
                    key = "thresh_ds%d_bkg%d_sub%d" % (dsNum, bIdx, sbIdx)
                    thD = dsi.getDBRecord(key, False, calDB, pars)

                    # 5. loop over cIdx's in this sub-bIdx
                    cIdxLo, cIdxHi = cal.GetCalIdx(calKey, subLo), cal.GetCalIdx(calKey, subHi)
                    for i, cIdx in enumerate(range(cIdxLo, cIdxHi+1)):

                        # get the run coverage of this sub-sub-bIdx
                        if cIdxLo==cIdxHi:
                            covLo, covHi = subLo, subHi
                        else:
                            runList = bkg.getRunList(ds, bIdx)
                            subList = [r for r in runList if subLo <= r <= subHi and cal.GetCalIdx(calKey,r) == cIdx]
                            if len(subList)==0: continue
                            covLo, covHi = subList[0], subList[-1]

                        # calculate exposure for this sub-sub-bIdx
                        subExpo = {ch:0 for ch in chList}
                        n = lt.Draw("run:channel:livetime","run>=%d && run<=%d" % (covLo, covHi), 'goff')
                        ltRun, ltChan, ltLive = lt.GetV1(), lt.GetV2(), lt.GetV3()
                        for j in range(n):
                            ch = ltChan[j]
                            detID = det.getDetIDChan(dsNum,ch)
                            aMass = det.allActiveMasses[detID]
                            expo = ltLive[j]*aMass/86400/1000

                            # since we're splitting by module, ignore channels in the other module
                            # print(ds, mod, int(cpd[0]))
                            # exit()

                            if ch < 1000 and mod!=1: continue
                            if ch > 1000 and mod!=2: continue

                            if ltRun[j] in psaCutRuns[ch]:
                                continue
                            if burstCutRuns[ltChan[j]] is True:
                                continue
                            subExpo[ch] += expo

                            if detID > 100000:
                                enrExp[ds] += expo
                            else:
                                natExp[ds] += expo

                        # 6. loop over channels
                        for ch in chList:

                            goodThr = True if bkgCov[ch][sbIdx] else False
                            goodSlo = True if calCov[ch][0][i+1] else False
                            goodRise = True if calCov[ch][1][i+1] else False
                            if not (goodThr and goodSlo and goodRise):
                                continue

                            # finally, get trigger, fitSlo, and riseNoise efficiencies and scale by exposure

                            # trigger
                            mu, sig, isGood = thD[ch]
                            if isGood != 0:
                                print("error, bad threshold, ch",ch)
                                exit(1)
                            effThresh = mu + 3*sig
                            idx = np.where(xEff >= effThresh)
                            nPad = len(xEff) - len(xEff[idx])
                            tEff = wl.erFunc(xEff[idx],mu,sig,1)
                            tEff = np.pad(tEff, (nPad,0), 'constant')
                            tEff = np.multiply(tEff, subExpo[ch])

                            trigEff[ch] += tEff

                            # fitSlo & riseNoise
                            cpd = int(det.getChanCPD(dsNum,ch))
                            c, loc, scale, amp = fsD[cpd][3], fsD[cpd][4], fsD[cpd][5], fsD[cpd][2]
                            fEff = wl.weibull(xEff,c,loc,scale,amp)

                            riseEff = 0.995 # riseNoise is defined to be 99.5% efficient, no energy dependence
                            fEff = np.multiply(fEff, riseEff)

                            fSloEff[ch] += fEff

                            # total efficiency
                            if mode == "trig":
                                totEff[ch] += tEff
                            elif mode == "all":
                                totEff[ch] += np.multiply(tEff, fEff) # this is what we want
                            else:
                                print("Unknown mode! exiting ...")
                                exit()

            # plot individual efficiencies for a data set
            cmap = plt.cm.get_cmap('jet',len(chList)+1)
            cpdList = sorted([det.getChanCPD(dsNum,ch) for ch in chList])
            for iD, cpd in enumerate(cpdList):
                ch = det.getCPDChan(dsNum, str(cpd))
                if det.allDetIDs[str(cpd)] < 100000: continue
                if np.all(trigEff[ch]==0): continue

                idx = np.where(xEff < 2)
                print(cpd, np.sum(trigEff[ch][idx]))

                plt.plot(xEff, trigEff[ch], '-', c=cmap(iD), label="C%sP%sD%s" % (cpd[0],cpd[1],cpd[2]))
                # plt.plot(xEff, fSloEff[ch], '-')
                # plt.plot(xEff, totEff[ch], '-')
            plt.xlim(0.5,6)
            plt.xlabel("Energy (keV)", ha='right', x=1)
            plt.ylabel("Enr. Exposure (kg-d)", ha='right', y=1)
            plt.legend(loc=4, ncol=3, fontsize=14)
            plt.tight_layout()
            # plt.show()
            plt.savefig("./plots/lat-trigEff-DS3.pdf")
            exit()

        #     for ch in chList:
        #         cpd = det.getChanCPD(dsNum,ch)
        #         detEff[ds][cpd] = totEff[ch]
        #         # print(ch, cpd, detEff[ds][cpd][500:520], totEff[ch][500:520])
        #
        #     # plt.plot(xEff,detEff[ds]['164'])
        #     # plt.show()
        #     # exit()
        #
        # # ========= Done w/ 5 layer loop.  whew! =======
        #
        # # get total enr/nat efficiency for this DS
        # for cpd in detEff[ds]:
        #
        #     if det.allDetIDs[cpd] > 100000:
        #         totEnrEff[ds] += detEff[ds][cpd]
        #     else:
        #         totNatEff[ds] += detEff[ds][cpd]


def hi_mult_cal_spec():
    """ Adapted from sandbox/mult4.py
    sumSpec : {mHT: histos}
    hitData : [mHT, sumET, dt[mHT]]
    hitList : [hitE, chan, fSlo, rise, dtpc]  (same length as hitData)
    """
    # f1 = np.load("./data/mult4-sumE.npz")
    # f2 = np.load("./data/mult4-hitE.npz")
    f1 = np.load("./data/mult4-sumE-histats.npz")
    f2 = np.load("./data/mult4-hitE-histats.npz")
    runTime, x, sumSpec = f1['arr_0'], f1['arr_1'], f1['arr_2'].item()
    hitSpec, xHit, hitSpecLo = f1['arr_3'].item(), f1['arr_4'], f1['arr_5'].item()
    hitList, hitData, eCut = f2['arr_1'], f2['arr_2'], f2['arr_3']

    xLo, xHi, xpb = 0, 4000, 1

    # counts & rates for each multiplicity (use mHT)
    nHits = [sum(sumSpec[i]) for i in range(7)]
    nErr = [np.sqrt(nHits[i]) for i in range(7)]
    nPct = [100 / nErr[i] if nHits[i] > 0 else 0 for i in range(7)]
    rate = [nHits[i] / runTime for i in range(7)]
    rErr = [nErr[i] / runTime for i in range(7)]

    # sum spectrum
    fig = plt.figure()
    xLo, xHi, xpb = 0, 4000, 2
    cols = [0,'r','b','m','g','c','k']
    for mHT in range(1,5):
        pLabel = r'mHT=%d %.2f $\pm$ %.3f Hz' % (mHT,rate[mHT],rErr[mHT])
        plt.semilogy(x, sumSpec[mHT], ls='steps', lw=1.5, c=cols[mHT],label=pLabel)
    plt.xlabel("sumET (keV)", ha='right', x=1.)
    plt.ylabel("Counts / %.1f keV" % (xpb), ha='right', y=1.)
    plt.legend(fontsize=14)
    plt.tight_layout()
    plt.savefig("./plots/lat-sumSpec.pdf")

    # sum spectrum, events w/ 1 or more hit under 'eCut' keV
    plt.cla()
    n = len(hitList)
    for mHT in range(2,5):
        evts = [hitData[i][1] for i in range(n) if hitData[i][0] == mHT]
        plt.semilogy(*wl.GetHisto(evts,xLo,xHi,xpb), ls='steps', lw=1.5, c=cols[mHT], label='mHT=%d, eCut:%.0f keV' % (mHT, eCut))
    plt.xlabel("sumE (keV)", ha='right', x=1.)
    plt.ylabel("Counts / %.1f keV" % (xpb), ha='right', y=1.)
    plt.legend(fontsize=14)
    plt.tight_layout()
    plt.savefig("./plots/lat-selectSpec.pdf")

    # hit spectrum
    plt.cla()
    for mHT in range(1,5):
        plt.semilogy(x, hitSpec[mHT], ls='steps', lw=1.5, c=cols[mHT], label='mHT=%d' % mHT)
    plt.xlabel("hitE (keV)", ha='right', x=1.)
    plt.ylabel("Counts / %.1f keV" % (xpb), ha='right', y=1.)
    plt.legend(fontsize=14)
    plt.tight_layout()
    plt.savefig("./plots/lat-hitSpec.pdf")

    # hit spectrum, under 20 kev
    plt.cla()
    for mHT in range(1,5):
        plt.semilogy(xHit, hitSpecLo[mHT], ls='steps', lw=1.5, c=cols[mHT], label='mHT=%d' % mHT)
    plt.xlabel("hitE (keV)", ha='right', x=1.)
    plt.ylabel("Counts / %.1f keV" % (xpb), ha='right', y=1.)
    plt.legend(loc=1, fontsize=14)
    plt.tight_layout()
    plt.savefig("./plots/lat-hitSpecLow.pdf")


def m2s238_sum_peak():

    # f = np.load("./data/mult2-peaks.npz")
    f = np.load("./data/mult2-peaks-histats.npz") # full cal run
    runTime, pks, pkHist = f['arr_0'], f['arr_1'], f['arr_2'].item()

    # note: to access x and y histogram values:
    # x, y = pkHist[mH][iPk][0], pkHist[mH][iPk][1]

    def roughSigma(ene):
        """ from gpxFitter, just used to set initial guesses """
        p0, p1, p2 = 0.2, 0.02, 0.0003
        return np.sqrt(p0**2. + p1**2. * ene + p2**2. * ene**2.)


    def gaus(x, b, a, mu, sig):
        """ gaussian + flat bg """
        return b + a * np.exp(-(x-mu)**2. / (2. * sig**2.))

    from scipy.optimize import curve_fit

    pkE, mH, iPk = 238, 2, 0

    x, y = pkHist[mH][iPk][0], pkHist[mH][iPk][1]

    # xpb = 0.1
    # x = x + xpb/2.

    fig = plt.figure()

    plt.plot(x, y, c='b', ls='steps-mid', label="Calib, mHT==%d" % (mH))

    p0 = (np.mean(y[:5]), max(y), pkE, roughSigma(pkE))
    popt,_ = curve_fit(gaus, x, y, p0=p0)

    bpx = x[1] - x[0]
    bgRate = popt[0] * bpx
    mu, sig = popt[2], popt[3]
    idx = np.where((x > mu-3*sig) & (x < mu+3*sig))
    totCts = np.sum(y[idx])
    bgCts = bgRate * len(y[idx])
    pkCts = totCts - bgCts
    pbr = pkCts / bgCts
    print("%d  %.2f  %.2f  %.2f  %.2f  %d  %d  %d  P/B: %.2f" % (pkE, bpx, bgRate, mu, sig, totCts, bgCts, pkCts, pbr))

    sumLo, sumHi = mu-3*sig, mu+3*sig
    print("sumLo, sumHi = %.2f, %.2f" % (mu-3*sig, mu+3*sig))

    xVals = np.arange(236, 240, 0.01)

    plt.plot(xVals, gaus(xVals, *popt), 'r-', lw=4, alpha=0.7, label="%s = %.2f, 3%s = %.2f" % (r'$\mu$', popt[2], r'$\sigma$', 3*popt[3]))

    # 'fit.  mu %.2f  sig %.2f\nP/B %.2f' % (popt[2], popt[3], pbr))
    plt.axvline(sumLo, lw=3, alpha=0.7, c='g', label="%.2f - %.2f keV" % (sumLo, sumHi))
    plt.axvline(sumHi, lw=3, alpha=0.7, c='g')
    plt.plot(np.nan, np.nan, c='w', label="P/B = %.1f" % pbr)

    # plt.title("Peak-to-bkg ratio: %.3f" % pbr)
    plt.xlabel("sumET (keV)", ha='right', x=1.)
    plt.ylabel("Counts", ha='right', y=1.)
    plt.legend(loc=1)
    plt.xlim(236,242)
    plt.tight_layout()
    # plt.show()
    plt.savefig("./plots/lat-m%d-pk%d.pdf" % (mH,iPk))


def m2s238_hit_spec():
    """
    Adapted from sandbox/mult4.py::plotSpecTest.
    sumSpec : {mHT: histos}
    hitData : [mHT, sumET, dt[mHT]]
    hitList : [hitE, chan, fSlo]  (same length as hitData)
    """
    f1 = np.load("./data/mult4-sumE-histats.npz")
    f2 = np.load("./data/mult4-hitE-histats.npz")
    runTime, x, sumSpec = f1['arr_0'], f1['arr_1'], f1['arr_2'].item()
    hitSpec, xHit, hitSpecLo = f1['arr_3'].item(), f1['arr_4'], f1['arr_5'].item()
    hitList, hitData, eCut = f2['arr_1'], f2['arr_2'], f2['arr_3']

    # fitSlo results from tuneFitSlo.
    fsVals = {
        584: 102.5, 592: 75.5, 608: 73.5, 610: 76.5, 614: 94.5, 624: 69.5,
        626: 81.5, 628: 102.5, 632: 81.5, 640: 73.5, 648: 74.5, 658: 75.5,
        660: 127.5, 662: 84.5, 672: 80.5, 678: 82.5, 680: 86.5, 688: 77.5,
        690: 80.5, 694: 80.5
        }
    chList = fsVals.keys()

    mHT = 2

    hitE, chan, fSlo = [], [], []
    for i in range(len(hitData)):
        if hitData[i][0]==mHT and 237.28 < hitData[i][1] < 239.46:
        # if hitData[i][0]==mHT and 235 < hitData[i][1] < 240:
            hitE.extend(hitList[i][0])
            chan.extend(hitList[i][1])
            fSlo.extend(hitList[i][2])
    n = len(hitE)
    hitE = [hitE[i] for i in range(n) if chan[i] in fsVals.keys()]
    fSloShift = [fSlo[i]-fsVals[chan[i]] for i in range(n) if chan[i] in chList]

    hitESlow = [hitE[i] for i in range(len(hitE)) if fSloShift[i] > 30]
    hitEFast = [hitE[i] for i in range(len(hitE)) if fSloShift[i] < 30]

    xLo, xHi, xpb = 0, 250, 1
    x, hSlo = wl.GetHisto(hitESlow,xLo,xHi,xpb)
    x, hFast = wl.GetHisto(hitEFast,xLo,xHi,xpb)

    # load sim data
    # fs = np.load("./data/mult4-evtTrans.npz")
    # hits = fs['arr_0'].item()
    # evtTotal, evtBulk, evtTrans = hits[0], hits[1], hits[2]
    # eneTotal, eneBulk, eneTrans = hits[3], hits[4], hits[5]
    # x, hTotal = wl.GetHisto(evtTotal, xLo, xHi, xpb)
    # x, hBulk = wl.GetHisto(evtBulk, xLo, xHi, xpb)
    # x, hTrans = wl.GetHisto(evtTrans, xLo, xHi, xpb)
    # x, hETotal = wl.GetHisto(eneTotal, xLo, xHi, xpb)
    # x, hEBulk = wl.GetHisto(eneBulk, xLo, xHi, xpb)
    # x, hETrans = wl.GetHisto(eneTrans, xLo, xHi, xpb)

    f = plt.figure()

    # plt.plot(x, hEBulk/np.sum(hEBulk), ls='steps', c='g', lw=2., label='sim bulk')
    # plt.plot(x, hFast/np.sum(hFast), ls='steps', c='b', lw=2., label='data fast')
    plt.plot(x, hFast, ls='steps', c='b', label="m2s238 Hits")
    plt.xlabel("Energy (keV)", ha='right', x=1)
    plt.ylabel("Counts / %.1f keV" % xpb, ha='right', y=1)
    plt.axvline(123.3, c='g', lw=4, alpha=0.7, label=r"$E_C$: 123.3 keV")

    plt.ylim(ymax=np.amax(hFast)*1.3)
    plt.legend(loc=1)
    plt.tight_layout()

    # plt.show()
    plt.savefig("./plots/lat-238hits.pdf")


def slowness_vs_energy():
    """ Adapted from LAT/sandbox/mult4.py
    hitData : [mHT, sumET, dt[mHT]]
    hitList : [hitE, chan, fSlo, rise, dtpc]  (same length as hitData)
    """
    applyShift = False

    # fitSlo results from tuneFitSlo.
    fsVals = {
        584: 102.5, 592: 75.5, 608: 73.5, 610: 76.5, 614: 94.5, 624: 69.5,
        626: 81.5, 628: 102.5, 632: 81.5, 640: 73.5, 648: 74.5, 658: 75.5,
        660: 127.5, 662: 84.5, 672: 80.5, 678: 82.5, 680: 86.5, 688: 77.5,
        690: 80.5, 694: 80.5
        }
    chList = list(fsVals.keys())

    mHT = 2

    f1 = np.load("./data/mult4-hitE.npz")
    # f1 = np.load("./data/mult4-hitE-histats.npz")
    runTime, hitList, hitData, eCut = f1['arr_0'], f1['arr_1'], f1['arr_2'], f1['arr_3']

    hitE, chan, fSlo = [], [], []
    for i in range(len(hitData)):
        if hitData[i][0]==mHT and 237.28 < hitData[i][1] < 239.46:  # m2s238 only
            hitE.extend(hitList[i][0])
            chan.extend(hitList[i][1])
            fSlo.extend(hitList[i][2])
    n = len(hitE)
    hitE = [hitE[i] for i in range(n) if chan[i] in fsVals.keys()]
    fSloShift = [fSlo[i]-fsVals[chan[i]] for i in range(n) if chan[i] in chList]
    fSloUnshift = [fSlo[i] for i in range(n) if chan[i] in chList]

    fig = plt.figure()

    xLo, xHi, xpb = 0, 250, 1
    nbx = int((xHi-xLo)/xpb)

    if applyShift:

        yLo, yHi, ypb = -50, 400, 1
        nby = int((yHi-yLo)/ypb)
        _,_,_,im = plt.hist2d(hitE, fSloShift, bins=[nbx, nby], range=[[xLo,xHi],[yLo,yHi]], norm=LogNorm(), cmap='jet')
        cb = plt.colorbar()

    else:

        # print(len(hitE), len(fSlo))
        # return

        yLo, yHi, ypb = -50, 400, 1
        nby = int((yHi-yLo)/ypb)
        _,_,_,im = plt.hist2d(hitE, fSloUnshift, bins=[nbx, nby], range=[[xLo,xHi],[yLo,yHi]], norm=LogNorm(), cmap='jet')
        cb = plt.colorbar()


    plt.xlabel("Energy (keV)", ha='right', x=1.)
    plt.ylabel("fitSlo", ha='right', y=1.)
    plt.tight_layout()
    plt.show()


    # plt.savefig("./lat/lat-fitSlo-hist.pdf")


if __name__=="__main__":
    main()